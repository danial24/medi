'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _AppDispatcher = require('./AppDispatcher');

var _AppDispatcher2 = _interopRequireDefault(_AppDispatcher);

var _eventemitter3 = require('eventemitter3');

var _eventemitter32 = _interopRequireDefault(_eventemitter3);

var CHANGE = 'change';
var ERROR = 'error';
var STATE = 'state';

var clone = function clone(o) {
  return JSON.parse(JSON.stringify(o));
};

var Store = (function (_EventEmitter) {
  _inherits(Store, _EventEmitter);

  function Store() {
    var initialState = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Store);

    _EventEmitter.call(this);

    // Store to be used only as an Abstract class
    if (this.constructor === Store) throw new Error('Store is an abstract class');

    this[STATE] = initialState;
    this.handler = this.handler.bind(this);

    this.dispatcher = _AppDispatcher2['default'];
    this.dispatchToken = _AppDispatcher2['default'].register(this.handler);
  }

  /*
   * State APIs
   */

  Store.prototype.get = function get(attr) {
    return attr ? this[STATE][attr] : this[STATE];
  };

  Store.prototype.set = function set(attr, val) {
    if (typeof attr === 'object') Object.assign(this[STATE], attr);else this[STATE][attr] = val;
  };

  Store.prototype.parse = function parse(data) {
    return typeof data === 'string' ? JSON.parse(data) : data;
  };

  Store.prototype.toJSON = function toJSON() {
    return clone(this[STATE]);
  };

  Store.prototype.emitChange = function emitChange(data) {
    this.emit(CHANGE, data);
  };

  Store.prototype.emitError = function emitError(err) {
    this.emit(ERROR, err);
  };

  /*
   * Store APIs
   */

  Store.prototype.subscribe = function subscribe(success, error) {
    this.on(CHANGE, success);
    error && this.on(ERROR, error);
  };

  Store.prototype.unsubscribe = function unsubscribe(success, error) {
    success && this.removeListener(CHANGE, success);
    error && this.removeListener(ERROR, error);
  };

  // for backward compatibility

  Store.create = function create(opts) {
    var actualHandler = opts.handler;
    if (process.env.NODE_ENV !== 'production') console.warn('Store has moved to a new API. Store.create() will be deprecated. Use\nimport {Store} from \'phrontend\';\nclass MyStore extends Store {\n  handler(payload) { }\n}\nlet store = new MyStore(initialState);\n');

    var MyStore = (function (_Store) {
      _inherits(MyStore, _Store);

      function MyStore() {
        _classCallCheck(this, MyStore);

        _Store.apply(this, arguments);
      }

      MyStore.prototype.handler = function handler(payload) {
        actualHandler.call(this, payload);
      };

      return MyStore;
    })(Store);

    return new MyStore();
  };

  return Store;
})(_eventemitter32['default']);

exports['default'] = Store;
module.exports = exports['default'];